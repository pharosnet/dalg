// This file is generated by pharosnet/dalg, please don't change it by hand.
package dal

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"github.com/pharosnet/dalc"
)

type User struct {
	Id         string
	Name       string
	Age        int64
	Gender     Gender
	Money      float64
	Info       UserInfo
	CreateBy   string
	CreateTime dalc.NullTime
	ModifyBy   string
	ModifyTime dalc.NullTime
	Version    int64
}

func (row User) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		fmt.Fprintf(
			s,
			"User(public.user) { Id(id): %v, Name(name): %v, Age(age): %v, Gender(sex): %v, Money(money): %v, Info(info): %v, CreateBy(create_by): %v, CreateTime(create_time): %v, ModifyBy(modify_by): %v, ModifyTime(modify_time): %v, Version(version): %v }",
			row.Id,
			row.Name,
			row.Age,
			row.Gender,
			row.Money,
			row.Info,
			row.CreateBy,
			row.CreateTime,
			row.ModifyBy,
			row.ModifyTime,
			row.Version,
		)
	}
}

func userScan(rows *sql.Rows) (*User, error) {
	row := &User{}
	err := rows.Scan(&row.Id,
		&row.Name,
		&row.Age,
		&row.Gender,
		&row.Money,
		&row.Info,
		&row.CreateBy,
		&row.CreateTime,
		&row.ModifyBy,
		&row.ModifyTime,
		&row.Version,
	)
	if err != nil {
		return nil, err
	}
	return row, nil
}

type UserQueryCallbackFunc func(ctx context.Context, row *User, rowErr error) (err error)

func userArrayMapToInterfacs(rows []*User) []interface{} {
	array := make([]interface{}, len(rows))
	for i, row := range rows {
		array[i] = row
	}
	return array
}

const userGetOneSQL = `SELECT "id", "name", "age", "sex", "money", "info", "create_by", "create_time", "modify_by", "modify_time", "version" FROM "public"."user" WHERE "id" = $1`

func UserGetOne(ctx context.Context, id string) (row *User, err error) {
	queryFn := func(ctx context.Context, rows *sql.Rows, rowErr error) (err error) {
		if rowErr != nil {
			err = rowErr
			return
		}
		user, scanErr := userScan(rows)
		if scanErr != nil {
			err = scanErr
			return
		}
		row = user
		return
	}
	if err = dalc.Query(ctx, userGetOneSQL, queryFn, id); err != nil {
		err = fmt.Errorf("User: get one failed, %v", err)
	}
	return
}

const userInsertSQL = `INSERT INTO "public"."user" ("id", "name", "age", "sex", "money", "info", "create_by", "create_time", "modify_by", "modify_time", "version") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)`

func UserInsert(ctx context.Context, rows ...*User) (affected int64, err error) {
	fn := func(ctx context.Context, stmt *sql.Stmt, arg interface{}) (result sql.Result, err error) {
		row, ok := arg.(*User)
		if !ok {
			err = errors.New("User: insert failed, invalid type")
			return
		}
		result, err = stmt.Exec(&row.Id,
			&row.Name,
			&row.Age,
			&row.Gender,
			&row.Money,
			&row.Info,
			&row.CreateBy,
			&row.CreateTime,
			&row.ModifyBy,
			&row.ModifyTime,
			&row.Version,
		)
		return
	}
	affected, err = dalc.Execute(ctx, userInsertSQL, fn, userArrayMapToInterfacs(rows)...)
	return
}

const userUpdateSQL = `UPDATE "public"."user" SET"name" = $1, "age" = $2, "sex" = $3, "money" = $4, "info" = $5, "create_by" = $6, "create_time" = $7, "modify_by" = $8, "modify_time" = $9, "version" = "version" + 1 WHERE "id" = $10 AND "version" = $11`

func UserUpdate(ctx context.Context, rows ...*User) (affected int64, err error) {
	fn := func(ctx context.Context, stmt *sql.Stmt, arg interface{}) (result sql.Result, err error) {
		row, ok := arg.(*User)
		if !ok {
			err = errors.New("User: update failed, invalid type")
			return
		}
		result, err = stmt.Exec(&row.Name,
			&row.Age,
			&row.Gender,
			&row.Money,
			&row.Info,
			&row.CreateBy,
			&row.CreateTime,
			&row.ModifyBy,
			&row.ModifyTime,
			&row.Id,
			&row.Version,
		)
		return
	}
	affected, err = dalc.Execute(ctx, userUpdateSQL, fn, userArrayMapToInterfacs(rows)...)
	return
}

const userDeleteSQL = `DELETE FROM "public"."user" WHERE "id" = $1 AND "version" = $2`

func UserDelete(ctx context.Context, rows ...*User) (affected int64, err error) {
	fn := func(ctx context.Context, stmt *sql.Stmt, arg interface{}) (result sql.Result, err error) {
		row, ok := arg.(*User)
		if !ok {
			err = errors.New("User: delete failed, invalid type")
			return
		}
		result, err = stmt.Exec(
			&row.Id,
			&row.Version,
		)
		return
	}
	affected, err = dalc.Execute(ctx, userDeleteSQL, fn, userArrayMapToInterfacs(rows)...)
	return
}

const userListSQL = `SELECT "id", "name", "age", "sex", "money", "info", "create_by", "create_time", "modify_by", "modify_time", "version" FROM "user" LIMIT $1 OFFSET $2`

func UserList(ctx context.Context, fn UserQueryCallbackFunc, limit int64, offset int64) (err error) {
	queryFn := func(ctx context.Context, rows *sql.Rows, rowErr error) (err error) {
		if rowErr != nil {
			err = fn(ctx, nil, rowErr)
			return
		}
		user, scanErr := userScan(rows)
		if scanErr != nil {
			err = fn(ctx, nil, scanErr)
			return
		}
		fn(ctx, user, nil)
		return
	}
	if err = dalc.Query(ctx, userListSQL, queryFn, limit, offset); err != nil {
		err = fmt.Errorf("query: UserList failed, %v", err)
	}
	return
}
